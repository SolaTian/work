# kafka

## 1、Kafka基本概念

### 1.1、什么是Kafka

> Kafka是一种分布式发布-订阅消息系统，主要用途就是实时数据流的处理和传输。

那么有个问题，什么是**消息系统**？

### 1.1.1、消息系统

消息系统：又叫消息中间件，负责将数据从一个应用传递到另一个应用，应用只需关注数据，无需关注数据在两个或者多个应用之间是如何传递的。

常见的消息系统除了`Kafka`，常见的还有：
- RabbitMQ：一个基于AMQP协议的消息队列；
- ActiveMQ：开源的消息中间件，支持多种消息协议；
等等。

消息系统的特点：
1. 实时性：消息系统能够将消息实时的传递给用户或者系统，在金融或者电商领域，实时性尤为重要；
2. 异步性：消息的发送和消息处理分离，降低了各个组件之间的耦合性，消息发送者只需要关注消息的发送，消息的接收者只需要关注消息的处理。
3. 支持多种消息传递模式（点对点式和发布订阅式），同时支持多种消息处理格式；
4. 跨平台和多设备支持：可以实现跨平台的消息推送。

那么什么是**发布-订阅**呢？

### 1.1.2、发布-订阅式与点对点式

消息系统的消息传递模式分为两种：一种是点对点（Point to Point,P2P）式，还有一种就是发布-订阅式，上面介绍的`RabbitMQ`和`ActiveMQ`就属于点对点式。

点对点式的特点就是：

1. 通过消息队列来实现，每条消息放入消息队列中，并且每条消息只能被一个消费者接收和处理。
2. 采用请求-响应模式，消息的发送和处理是一次性的。例如，在拼多多上购物时，订单处理系统中的支付请求。
3. 负载均衡：如果有多个消费者，消息会在消费者之间进行负载均衡，消费者的数量可以根据处理能力进行调整，但是被某个消费者消费过的消息就不能再被消费了。

点对点模式如下图：

![点对点模式](https://img2022.cnblogs.com/blog/2591061/202211/2591061-20221113153810167-372719945.png)


发布订阅模式如下图：

![发布订阅模式](https://img2022.cnblogs.com/blog/2591061/202211/2591061-20221113154118350-462490901.png)

点对点式和发布订阅式的区别
|特点|发布订阅式|点对点式|
|-|-|-|
|通信方式|通过消息代理进行间接通信|生产者直接发送给指定的消费者|
|耦合度|松耦合，各个组件或者模块的依赖关系较弱|紧耦合，各个组件或者模块的依赖关系较强|
|消息传递|异步|同步或者异步|
|消息消费|多订阅，一个消息可以被多个消费者消费|单订阅，一个消息只能被一个消费者消费|
|消息过滤|支持灵活的消息过滤，只接收和处理自己感兴趣的消息|不支持或者支持有限的消息过滤|
|可靠性和持久性|通常使用消息队列和主题来确保消息的可靠性和持久性|依赖于生产者和消费者的直接通信，可能缺乏可靠性保证|
|应用场景|适用于需要广播消息给多个消费者的场景。<li>租房信息订阅；<li>股票信息订阅；<li>在线购物网站的内容推荐|适用于需要确保消息按顺序被单个消费者处理的场景。<li>微信好友间聊天；<li>银行转账；|


### 1.2、Kafka的组成

Kafka由以下部分组成：

|Kafka组成|功能|特点|
|-|-|-|
|生产者`Producer`|将消息发送到指定的`topic`，并且可以指定消息发送到哪个`partition`|生产者发送消息是异步的，支持批量发送以提高性能。|
|消费者`Consumer`|通过订阅一个或多个`topic`，并从这些`topic`中拉取（pull）消息进行消费|消费者支持分组（`Group`）概念，一个消费者组内的消费者可以共同消费一个`topic`的多个`partition`，以实现负载均衡和容错，同时，一个分区只能被指定给一个消费。|
|节点`Broker`|`Kafka`集群中的每个服务器节点被称为一个`Broker`，负责存储消息数据，并提供消息生产和消费的服务|`Broker`集群通过`Zookeeper`进行管理和协调，以实现高可用性和数据一致性|
|主题`Topic`|`Topic`是`Kafka`中用于存储消息的逻辑分类，每个`Topic`都包含多个`partition`，用于分散消息的存储和消费。主题类似于数据库的表。|<li>生产者向`Topic`发送消息，消费者从`Topic`订阅并消费消息；<li>不同主题的消息是物理隔离的；<li>`Topic`有一个或者多个分区；<li>同一个主题的消息保存在一个或者多个`Broker`上，用户只需要指定`Topic`即可以生产或者消费，不必关心存于何处。|
|分区`Partition`|`Partition`是`Topic`的物理分区，用于实现消息的并行处理和存储|每个`Partition`可以有多个副本（`Replica`）以提高数据的可靠性和可用性|
|消息`message`|`Kafka`的数据单元称作消息|由字节数组成|
|批次`batch`|批次就是一组消息|同属于一个`Broker`和`Partition`|
|`Replica`|`Replica`是`Partition`的副本，用于实现数据的冗余和容错。每个`Partition`都有一个`Leader`副本和多个`Follower`副本。`Leader`副本负责处理读写请求(生产者发送数据的对象，消费者消费数据的对象)，`Follower`副本从`Leader`副本复制数据以保持数据一致性|当`Leader`副本出现故障时，`Kafka`会自动从`Follower`副本中选举出新的`Leader`副本，以保证服务的连续性|
|`Zookeeper`|`Zookeeper`不是`Kafka`的直接组成部分，但它在`Kafka`集群中扮演着至关重要的角色，管理`Kafka`集群的元数据（如`Broker`信息、`Topic`信息、`Partition`信息等），并协调`Broker`之间的交互和选举。|`Zookeeper`的高可用性和强一致性保证了`Kafka`集群的稳定性和可靠性|


### 1.2、Kafka的特点

`Kafka`具有以下特点：

1. 高吞吐量：`Kafka`的组成决定了其有高吞吐量的特点，可以处理非常高的消息吞吐量，适用于大规模数据处理和实时数据流；
2. 持久性：`Kafka`将消息持久化到磁盘中，即使消费者出现故障或者网络中断，消息也不会丢失；
3. 可靠性：`Kafka`通过副本机制保证消息的可靠性。每个`Partition`都有多个副本，分布在不同的`Broker`上，从而提高了数据的冗余性和容错性。即使某些节点发生故障，`Kafka`也能通过副本机制自动恢复数据的完整性;
4. 可伸缩性：`Kafka`采用分布式架构，可以方便地进行水平扩展，以应对不断增长的数据和负载需求。通过添加新的节点，可以线性扩展`Kafka`集群的处理能力，保证了系统的可靠性和性能;
5. 低延迟：`Kafka`设计用于实时数据流处理，因此具有较低的传输延迟；

`Kafka`的组成决定了其高吞吐量的特点，而高吞吐量又是其能够削峰的基础。`Kafka`作为中间件，可以将上游系统产生的突发流量暂存到`Kafka`的消息队列中，而不是直接发送到下游系统。这样，下游系统就可以按照自己的处理节奏，从`Kafka`中逐步消费这些消息，从而避免了因为突发流量而导致的系统崩溃。


同样地，削峰有助于实现高吞吐量：通过削峰，`Kafka`能够将突发的高峰流量平滑地分散到队列中，避免了因为流量洪峰而导致的系统崩溃或响应延迟。这样，系统就能够更加稳定地运行，并保持较高的吞吐量。


`Kafka`削峰的应用场景：
- 电商秒杀：由于用户会在短时间内集中访问系统，导致系统面临巨大的访问压力。通过引入`Kafka`作为消息队列，可以将用户的请求暂存到`Kafka`中，然后逐步推送给下游系统进行处理，从而避免了系统崩溃和响应延迟。
- 日志收集与处理：在大型系统中，日志的收集和处理是一个重要的任务。由于系统可能产生大量的日志数据，如果直接将这些数据推送到处理系统，可能会导致处理系统无法承受。通过Kafka进行削峰处理，可以将日志数据暂存到`Kafka`中，然后逐步推送给处理系统进行处理。


## 2、Kafka原理

要真正吃透`Kafka`的底层原理很不容易。这里也只是大概的介绍一下`Kafka`的大致工作原理。

除了之前提到的`Kafka`的组成，在介绍原理之前，还有几个术语需要介绍一下
- 消息偏移量`offset`：表示分区`Partition`中每条消息的位置信息，是一个单调递增且不变的值。

![Kafka基础架构](https://img2022.cnblogs.com/blog/2591061/202211/2591061-20221113155143571-1630948393.png)


### 2.1、Kafka的管理和支持——Zookeeper

`Zookeeper`是一个分布式协调服务。`Kafka`是使用的`Zookeeper`来构建的分布式服务。
其主要负责的功能包括：
1. 元数据管理：`Zookeeper`存储和管理`Kafka`集群的元数据，包括：`Topic`，`Partition`，`offset`以及`Replica`；
2. 集群管理：当`Kafka`中有新的`Broker`加入或者离开时，`Zookeeper`负责通知和协调集群中的其他`Broker`，保持集群的一致性；
3. `Leader`选举：`Kafka`通过`Zookeeper`实现分区的`Leader`选举。


在`Kafka`中，`Zookeeper`以服务器的形式存在。但需要注意的是，这里的“服务器”并不是指它直接提供`Kafka`消息队列服务，而是指`Zookeeper`作为一个独立的进程或服务运行在服务器上，用于为`Kafka`集群提供分布式协调服务。

在实际部署中，`Zookeeper`服务器集群通常会与`Kafka`集群分开部署，以确保它们之间的独立性和可扩展性。

`Zookeeper`和`Kafka`的关系好比是，管理者和打工仔的关系，`Zookeeper`负责全局的协调和管理，`Kafka`负责处理具体的事务，相互协调使得分布式系统稳定运行。


### 2.2、Kafka结点的领导者——Controller

> Controller：是Kafka集群中的一个特殊的Broker，它除了像普通Broker那样对外提供消息的生产、消费、同步功能外，还额外承担了管理Kafka集群的Broker、Topic、分区等职责。

#### 2.2.1、Controller的选举过程

`Kafka`集群中的每一个`Broker`都有可能成为`Controller`，具体的选举依赖于`Zookeeper`。

选举流程：
1. 候选者注册：在`Kafka`集群启动时，每个`Broker`都有可能成为`Controller`的候选者。各候选者会在`Zookeeper`中创建临时有序节点（通常是`/controller`）来表明自己的参与。这些节点是临时的，意味着当`Broker`宕机或退出集群时，相应的节点会被自动删除；
2. 节点的排序与选举：`Zookeeper`对候选者结点进行排序，具有最小序号的节点成为新的`Controller`，如果多个候选者具有相同的最小序号，那么`Zookeeper`会根据节点的创建时间来选择最终的`Controller`；
3. 选举完成：一旦选举完成，新的`Controller`节点将被选出，并且其他候选者将知道哪个节点成为了新的`Controller`。新的`Controller`节点将负责管理`Kafka`集群的状态、执行分区分配、`Leader`选举等操作；
4. 故障转移和重新选举：当前的`Controller`节点发生故障或失效时，`Kafka`集群会自动触发`Controller`的重新选举过程。这个过程由`Zookeeper`的临时节点和节点监听机制来保证。新的`Controller`候选者将尝试在`Zookeeper`中创建临时有序节点，参与新一轮的`Controller`选举过程。`ZooKeeper`将重新处理候选者节点，选举出新的`Controller`节点，并接管集群管理任务，确保`Kafka`集群的正常运行和高可用性。


#### 2.2.2、Controller的职责

1. 集群的状态管理：
   1. 监控集群中`Broker`的增减变化，包括`Broker`的加入，主动关闭和宕机；
   2. 分区与副本管理：`Controller`负责管理和监控集群中所有分区的状态，包括分区的创建、删除、状态转换以及副本的选举和状态更新。它通过`ZooKeeper`来协调这些任务，确保分区和副本的高可用性和一致性;
2. 元数据管理：`Controller`还负责维护集群的元数据信息，从`Zookeeper`中读取和更新集群的元数据信息，如`Topic`的分区信息、每个分区的`Leader`副本信息。当集群中的元数据发生变化时，`Controller`会及时更新集群元数据并将更新后的信息同步给集群中的所有`Broker`，确保每个`Broker`都能获取到最新的元数据信息；
3. 故障切换与内容复制：当分区的`Leader`副本发生故障时，`Controller`负责进行故障切换，选举新的`Leader`副本，并确保数据的正确复制和同步；



> ISR列表：指与领导者副本保持同步的追随者副本集合，即这些副本已经复制了领导者副本的所有数据，并且它们的落后时间在一定范围内。

`Kafka`分区和副本数据采用状态机方式进行管理：

- 分区状态机：
  - NonExistentPartition：该状态表示分区没有被创建过或创建后被删除了
  - NewPartition：分区刚创建后，处于这个状态。此状态下分区已经分配了副本，但是还没有选举`leader`，也没有`ISR`列表
  - OnlinePartition：一旦这个分区的`leader`被选举出来，将处于这个状态
  - OfflinePartition：当分区的`leader`宕机，转移到这个状态
![分区状态机的切换](https://s6.51cto.com/oss/202104/09/f4d16e834f83f10f4f2cb4b860da35e9.png)

- 副本状态机：
  - NewReplica: 创建`topic`和分区分配后创建`replicas`，此时，`replica`只能获取到成为`follower`状态变化请求。
  - OnlineReplica: 当`replica`成为`parition`的`assingned replicas`时，其状态变为 OnlineReplica, 即一个有效的OnlineReplica。
  - OfflineReplica: 当一个`replica`下线，进入此状态，这一般发生在`broker`宕机的情况下
  - NonExistentReplica: `Replica` 成功删除后，`replica` 进入 NonExistentReplica 状态

![副本状态机的切换](https://s2.51cto.com/oss/202104/09/de8f7c8bd4557cb535c4bf70d2afe0f6.png)