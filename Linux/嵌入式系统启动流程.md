# 嵌入式系统启动分析

- [嵌入式系统启动分析](#嵌入式系统启动分析)
  - [1、设备升级（程序烧录）](#1设备升级程序烧录)
    - [1.1、网页端升级](#11网页端升级)
    - [1.2、串口升级](#12串口升级)
    - [1.3、通过某种 demo 升级](#13通过某种-demo-升级)
  - [2、硬件上电与复位](#2硬件上电与复位)
    - [2.1、片上 ROM 的初始化代码执行](#21片上-rom-的初始化代码执行)
    - [2.2、引导加载程序 BL1 加载与执行](#22引导加载程序-bl1-加载与执行)
    - [2.3、引导加载程序 BL2 加载与执行](#23引导加载程序-bl2-加载与执行)
  - [3、BootLoader（启动加载器）](#3bootloader启动加载器)
  - [4、内核（Kernel）](#4内核kernel)
    - [4.1、init 进程](#41init-进程)
  - [5、应用启动脚本(initrun.sh)](#5应用启动脚本initrunsh)

## 1、设备升级（程序烧录）

### 1.1、网页端升级


### 1.2、串口升级

串口升级是一种利用串口通信在设备和外部计算机之间传输数据。

当嵌入式设备死机无法启动，没有办法通过 web 升级时。常常需要使用串口升级。

U-Boot 支持多种通信协议，包括串口。很多嵌入式设备会利用 U-Boot 来完成串口升级操作。关于 U-Boot 的介绍在下面，可以先看一看。

> 串口升级原理：当设备进入 U-Boot 菜单时，U-Boot 会开始监听串口，一旦接收到外部发送的固件数据，U-Boot 就会按照预设的规则将数据存储到指定的闪存（FLASH）中。

串口升级的准备工作：
1. 计算机和嵌入式设备通过串口线连接，能够通过串口中断 U-Boot 自启动并设置网络参数。
2. 计算机上安装好 TFTP 服务器，并在TFTP 指定目录下放置固件文件。
3. 计算机与嵌入式设备之前通过网线连接。


|串口升级的过程|说明|通信方式|
|-|-|-|
|设备拔电重启|设备进入 U-Boot 阶段，U-Boot 监听串口。用户通过串口输入命令，中断 U-Boot 的自启动，进入 U-Boot 命令行界面|通过串口与 U-boot 进行交互|
|网络参数配置|用户通过串口配置嵌入式设备的网络参数<li>setenv ipaddr <嵌入式设备IP 地址><li> setdnv serverip <电脑 IP 地址>设置 TFTP 服务器的 IP 地址（如果嵌入式设备与计算机之间不是直连，可能还需要设置网关 setenv gatewayip <设备网关>）<li>saveenv 保存设置好的网络参数|通过串口与 U-boot 进行交互|
|固件文件传输|在 U-Boot 环境下，通过 tftp <目标内存地址> <固件文件名>或者 upgrade 命令发起文件传输请求，U-Boot 会根据上一步配置的网络参数，与电脑上的 TFTP 服务器建立连接，通过网线进行数据传输，将固件文件从电脑上下载到嵌入式设备的指定内存地址|TFTP 网络传输|
|固件写入与升级重启|固件文件传输下载到嵌入式设备内存之后，U-Boot 会将其写入到设备的存储介质（如FLASH），写入完成后通过输入 reset 命令重启设备（如果上一步使用了 upgrade 命令，则这一步可能不需要）||




### 1.3、通过某种 demo 升级



## 2、硬件上电与复位

在嵌入式系统上电之后，电源模块会为系统各个组件提供所需的电压和电流。且会产生一个复位信号，该信号会将处理器和其他的硬件组件的状态恢复成为初始状态。CPU 会从一个固定的地址开始执行代码。这个地址通常是由硬件设计决定的。

### 2.1、片上 ROM 的初始化代码执行

上电和复位之后，并不会立刻进入 U-Boot，而是先执行一个固化在 ROM 上的初始代码（汇编，可能会掺杂一些 C ），这段代码由硬件厂家预先编写好。

这段代码的主要作用是：

1. 对 CPU 的一些基本硬件进行检查和初始化，如时钟系统、内存控制器等
2. 设置系统时钟频率，确保 CPU 和其他组件能够在正确的时钟信号下工作
3. 初始化内存控制器
4. 根据复位的引脚电平状态决定从哪个存储设备加载后续的引导代码。常见的引导源包括：
   - 内部 FLASH
   - 外部 SD 卡
   - NAND FLASH 等  

### 2.2、引导加载程序 BL1 加载与执行

确定好引导源之后，片上 ROM 的初始代码会从相应的存储设备中读取第一段加载引导程序（BL1，汇编语言）到内部 SRAM 中，交接棒到 BL1。

BL1 同样很简短，其主要的任务：
1. 进一步初始化硬件，尤其是外部存储控制器，以便能够访问更大容量的外部内存（如 DDR SDRAM）。
2. 对存储设备进行初始化，为后续加载第二阶段引导加载程序（BL2）做好准备。


### 2.3、引导加载程序 BL2 加载与执行

外部内存初始化完成后，BL1 会从存储设备中读取第二阶段引导加载程序（BL2，）到外部内存中，交接到 BL2 手中。

BL2 比 BL1 的体积大，因此需要外部内存来存储和执行。

BL2 的主要任务是进行更全面的硬件初始化，包括：
1. 串口、网卡、USB 等设备的初始化；
2. 对文件系统进行初始化，以便能够从存储设备读取更加复杂的文件；
3. 将 BootLoader 加载到内存中的指定地址。


## 3、BootLoader（启动加载器）

终于到了 BootLoadr，BootLoader 有很多种，以下列出：

|分类|应用领域|
|-|-|
|U-Boot|应用范围包括智能手机、平板电脑、路由器、工业控制设备等|
|RedBoot|常用于一些对成本和资源要求较高的嵌入式设备，如智能家居设备、小型工业控制器等|
|Grub|常用于需要支持多操作系统引导的设备中，如一些工业电脑、车载电脑等|

它们的关系就好比是类和实例的关系。

以下介绍 BootLoader 就以 U-Boot 为例。

BL2 将 U-Boot 镜像从存储设备加载到内存的指定地址。U-Boot 镜像通常包括代码段、数据段和 BSS 段等，加载过程需要确保这些段被正确地放置在内存中。加载完成之后，会跳转到 U-Boot 的入口地址。

U-Boot 的主要任务包括以下：
1. 硬件初始化：包括但不限于设置CPU的运行模式、初始化时钟系统以确保CPU和其他硬件能在合适的频率下工作、配置内存控制器使系统能够正确访问外部内存、初始化中断控制器以处理系统运行过程中的各种中断事件等。
2. 建立内存空间映射：明确不同内存区域的用途，如代码段、数据段、堆栈段的起始地址和大小，帮助操作系统内核和应用程序能够正确访问和管理内存资源。
3. 加载并启动操作系统内核：从存储设备（如 FLASH、SD 卡中）读取操作系统内核镜像文件，并加载到内存中的指定位置。通过设置必要的参数（内核命令行参数）和环境，跳转到内核的入口地址，启动操作系统。
4. 提供用户交互界面：一些 BootLoader 会提供命令行或菜单界面，允许在系统启动中进行一些操作，如修改启动参数、选择不同的启动选项等。U-Boot 为例，用户可以在启动时通过串口或者网络连接到开发板，修改一些环境变量、执行文件传输命令、加载不同的内核镜像等。


## 4、内核（Kernel）

内核随后接管控制，其主要工作包括以下：

1. 硬件初始化，继续进行更深入的硬件初始化工作，探测系统中的各种硬件设备，如网卡，硬盘，USB 设备等。
2. 内存管理初始化：内核进一步完善内存管理机制，对系统的物理内存进行分页，建立虚拟内存映射，为后续进程运行分配内存空间。同时也会初始化内核自身的数据结构和缓冲区，确保内核能够合理使用内存资源。
3. 进程管理初始化：内核创建第一个用户级进程，即 init 进程（在 Systemd 出现后，通常由 Systemd 替代 init 进程的角色）。这个进程是所有用户进程的祖先，进程ID（PID）为 1。init 进程的启动标志系统从内核空间进入用户空间。

### 4.1、init 进程

init 进程会去读取配置文件，根据配置文件中的指令去执行各种启动脚本

init 进程有两种类型：
1. 传统 SysVinit：传统 Linux 系统，init 进程会读取 /etc/inittab 配置文件，如下
   
        # ls /etc
        S_udev        group         inittab       psh_rsa.conf  shells
        TZ            hosts         my.cnf        resolv.conf   udev
        app           inetd.conf    passwd        services      udev.conf
        dropbear      init.d        profile       sh_tmo

        #cat /etc/inittab
        ::sysinit:/etc/init.d/rcS
        ::respawn:-/bin/psh
        ::restart:/sbin/init

        # cat /etc/init.d/rcS
        #! /bin/sh
        /bin/mount -t proc proc /proc
        /bin/mount -t sysfs sysfs /sys
        /bin/mount -t ramfs ramfs /home
        /sbin/iptables -A INPUT -p tcp --dport 22 -j DROP

        /etc/app

2. Systemd：现代 Linux 系统使用 Systemd 作为 init 进程，采用并行启动方式，提升了系统的启动速度，读取 /etc/systemd 目录下的配置文件

inittab 配置文件格式为

    id:runlevels:action:process

字段含义如下：
- id: 表示特定标识符，可为空
- runlevels：运行级别，为空表示适用所有运行级别
  - 0：关机状态
  - 1：单用户模式
  - 2-5：多用户模式
  - 6：重启状态
- action：指定系统在何时以及如何执行 process 字段中的进程
  - sysinit：在系统初始化阶段执行，通常用于完成一些基本的系统设置，如挂载文件系统、启动 udev 服务等。inittab 文件中通常只有一个 sysinit 动作的配置项。
  - respawn：如果指定的进程终止，系统会自动重新启动该进程，确保进程始终处于运行状态。常用于需要持续运行的服务，如登录 shell 进程。
  - wait：系统会等待指定的进程执行完毕后才会继续执行 inittab 文件中的下一个配置项。
  - once：进程只在进入相应运行级别时执行一次，不会自动重启。
  - restart：当 init 进程接收到特定的信号（通常是 SIGHUP）时，会重新启动指定的进程。
  - ctrlaltdel：当用户按下 Ctrl + Alt + Del 组合键时，执行指定的进程，通常用于实现系统重启功能。
  - shutdown：在系统关机时执行指定的进程，用于完成一些清理工作。
- process：要执行的脚本路径

可以看到 ::sysinit:/etc/init.d/rcS 这个表示的就是：在系统启动时，会首先执行 /etc/init.d/rcS 脚本

再来看上面的 /etc/init.d/rcS 这个脚本内容，它首先挂载了必要的文件系统（proc 文件系统，sysfs 文件系统，ramfs 文件系统）到指定目录、配置防火墙规则，并执行自定义的应用程序初始化脚本。这个 /etc/app 脚本就是自定义的应用程序脚本了。

这个脚本会根据具体的嵌入式系统完成一些如分区挂载，网络接口配置，执行初始化脚本（如initrun.sh）等工作。

## 5、应用启动脚本(initrun.sh)

这就是嵌入式系统的定制化脚本了，常常会有以下配置：

- 挂载文件系统
- 系统参数配置
- 加载动态库资源和可执行文件资源
- 加载驱动
- 配置网卡，启用 ssh 等
- 加载具体的嵌入式业务进程 

确保整个系统能够正常运行。

